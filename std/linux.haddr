const SYS_read: i64 = 0;
const SYS_write: i64 = 1;
const SYS_open: i64 = 2;
const SYS_close: i64 = 3;
const SYS_fstat: i64 = 5;
const SYS_mmap: i64 = 9;
const SYS_munmap: i64 = 11;
const SYS_ioctl: i64 = 16;
const SYS_nanosleep: i64 = 35;
const SYS_getpid: i64 = 39;
const SYS_clone: i64 = 56;
const SYS_fork: i64 = 57;
const SYS_vfork: i64 = 58;
const SYS_execve: i64 = 59;
const SYS_exit: i64 = 60;
const SYS_wait4: i64 = 61;
const SYS_fcntl: i64 = 72;
const SYS_waitid: i64 = 247;

const stdin: i64 = 0;
const stdout: i64 = 1;

const O_RDONLY: i64 = 0;
const O_WRONLY: i64 = 1;
const O_RDWR: i64 = 2;
const O_NONBLOCK: i64 = 2048;

const F_GETFL: i64 = 3;
const F_SETFL: i64 = 4;

const TCGETS: i64 = 21505;
const TCSETS: i64 = 21506;
const TCSANOW: i64 = 0;

const PROT_EXEC: i64 = 4;
const PROT_READ: i64 = 1;
const PROT_WRITE: i64 = 2;
const PROT_NONE: i64 = 0;

const MAP_PRIVATE: i64 = 2;
const MAP_SHARED: i64 = 1;
const MAP_ANONYMOUS: i64 = 32;

const EPERM: i64 = 1;
const ENOENT: i64 = 2;
const ESRCH: i64 = 3;
const EINTR: i64 = 4;
const EIO: i64 = 5;
const ENXIO: i64 = 6;
const E2BIG: i64 = 7;
const ENOEXEC: i64 = 8;
const EBADF: i64 = 9;
const ECHILD: i64 = 10;
const EAGAIN: i64 = 11;
const ENOMEM: i64 = 12;
const EACCES: i64 = 13;
const EFAULT: i64 = 14;
const ENOTBLK: i64 = 15;
const EBUSY: i64 = 16;
const EEXIST: i64 = 17;
const EXDEV: i64 = 18;
const ENODEV: i64 = 19;
const ENOTDIR: i64 = 20;
const EISDIR: i64 = 21;
const EINVAL: i64 = 22;
const ENFILE: i64 = 23;
const EMFILE: i64 = 24;
const ENOTTY: i64 = 25;
const ETXTBSY: i64 = 26;
const EFBIG: i64 = 27;
const ENOSPC: i64 = 28;
const ESPIPE: i64 = 29;
const EROFS: i64 = 30;
const EMLINK: i64 = 31;
const EPIPE: i64 = 32;
const EDOM: i64 = 33;
const ERANGE: i64 = 34;
const EDEADLK: i64 = 35;
const ENAMETOOLONG: i64 = 36;
const ENOLCK: i64 = 37;
const ENOSYS: i64 = 38;
const ENOTEMPTY: i64 = 39;
const ELOOP: i64 = 40;
const EWOULDBLOCK: i64 = 11;
const ENOMSG: i64 = 42;
const EIDRM: i64 = 43;
const ECHRNG: i64 = 44;
const EL2NSYNC: i64 = 45;
const EL3HLT: i64 = 46;
const EL3RST: i64 = 47;
const ELNRNG: i64 = 48;
const EUNATCH: i64 = 49;
const ENOCSI: i64 = 50;
const EL2HLT: i64 = 51;
const EBADE: i64 = 52;
const EBADR: i64 = 53;
const EXFULL: i64 = 54;
const ENOANO: i64 = 55;
const EBADRQC: i64 = 56;
const EBADSLT: i64 = 57;
const EDEADLOCK: i64 = 35;
const EBFONT: i64 = 59;
const ENOSTR: i64 = 60;
const ENODATA: i64 = 61;
const ETIME: i64 = 62;
const ENOSR: i64 = 63;
const ENONET: i64 = 64;
const ENOPKG: i64 = 65;
const EREMOTE: i64 = 66;
const ENOLINK: i64 = 67;
const EADV: i64 = 68;
const ESRMNT: i64 = 69;
const ECOMM: i64 = 70;
const EPROTO: i64 = 71;
const EMULTIHOP: i64 = 72;
const EDOTDOT: i64 = 73;
const EBADMSG: i64 = 74;
const EOVERFLOW: i64 = 75;
const ENOTUNIQ: i64 = 76;
const EBADFD: i64 = 77;
const EREMCHG: i64 = 78;
const ELIBACC: i64 = 79;
const ELIBBAD: i64 = 80;
const ELIBSCN: i64 = 81;
const ELIBMAX: i64 = 82;
const ELIBEXEC: i64 = 83;
const EILSEQ: i64 = 84;
const ERESTART: i64 = 85;
const ESTRPIPE: i64 = 86;
const EUSERS: i64 = 87;
const ENOTSOCK: i64 = 88;
const EDESTADDRREQ: i64 = 89;
const EMSGSIZE: i64 = 90;
const EPROTOTYPE: i64 = 91;
const ENOPROTOOPT: i64 = 92;
const EPROTONOSUPPORT: i64 = 93;
const ESOCKTNOSUPPORT: i64 = 94;
const EOPNOTSUPP: i64 = 95;
const EPFNOSUPPORT: i64 = 96;
const EAFNOSUPPORT: i64 = 97;
const EADDRINUSE: i64 = 98;
const EADDRNOTAVAIL: i64 = 99;
const ENETDOWN: i64 = 100;
const ENETUNREACH: i64 = 101;
const ENETRESET: i64 = 102;
const ECONNABORTED: i64 = 103;
const ECONNRESET: i64 = 104;
const ENOBUFS: i64 = 105;
const EISCONN: i64 = 106;
const ENOTCONN: i64 = 107;
const ESHUTDOWN: i64 = 108;
const ETOOMANYREFS: i64 = 109;
const ETIMEDOUT: i64 = 110;
const ECONNREFUSED: i64 = 111;
const EHOSTDOWN: i64 = 112;
const EHOSTUNREACH: i64 = 113;
const EALREADY: i64 = 114;
const EINPROGRESS: i64 = 115;
const ESTALE: i64 = 116;
const EUCLEAN: i64 = 117;
const ENOTNAM: i64 = 118;
const ENAVAIL: i64 = 119;
const EISNAM: i64 = 120;
const EREMOTEIO: i64 = 121;
const EDQUOT: i64 = 122;
const ENOMEDIUM: i64 = 123;
const EMEDIUMTYPE: i64 = 124;
const ECANCELED: i64 = 125;
const ENOKEY: i64 = 126;
const EKEYEXPIRED: i64 = 127;
const EKEYREVOKED: i64 = 128;
const EKEYREJECTED: i64 = 129;
const EOWNERDEAD: i64 = 130;
const ENOTRECOVERABLE: i64 = 131;
const ERFKILL: i64 = 132;
const EHWPOISON: i64 = 133;

proc strerror(err: i64) -> *i8 {
  if (err == 1) return "Operation not permitted";
  else if (err == 2) return "No such file or directory";
  else if (err == 3) return "No such process";
  else if (err == 4) return "Interrupted system call";
  else if (err == 5) return "Input/output error";
  else if (err == 6) return "No such device or address";
  else if (err == 7) return "Argument list too long";
  else if (err == 8) return "Exec format error";
  else if (err == 9) return "Bad file descriptor";
  else if (err == 10) return "No child processes";
  else if (err == 11) return "Resource temporarily unavailable";
  else if (err == 12) return "Cannot allocate memory";
  else if (err == 13) return "Permission denied";
  else if (err == 14) return "Bad address";
  else if (err == 15) return "Block device required";
  else if (err == 16) return "Device or resource busy";
  else if (err == 17) return "File exists";
  else if (err == 18) return "Invalid cross-device link";
  else if (err == 19) return "No such device";
  else if (err == 20) return "Not a directory";
  else if (err == 21) return "Is a directory";
  else if (err == 22) return "Invalid argument";
  else if (err == 23) return "Too many open files in system";
  else if (err == 24) return "Too many open files";
  else if (err == 25) return "Inappropriate ioctl for device";
  else if (err == 26) return "Text file busy";
  else if (err == 27) return "File too large";
  else if (err == 28) return "No space left on device";
  else if (err == 29) return "Illegal seek";
  else if (err == 30) return "Read-only file system";
  else if (err == 31) return "Too many links";
  else if (err == 32) return "Broken pipe";
  else if (err == 33) return "Numerical argument out of domain";
  else if (err == 34) return "Numerical result out of range";
  else if (err == 35) return "Resource deadlock avoided";
  else if (err == 36) return "File name too long";
  else if (err == 37) return "No locks available";
  else if (err == 38) return "Function not implemented";
  else if (err == 39) return "Directory not empty";
  else if (err == 40) return "Too many levels of symbolic links";
  else if (err == 11) return "Resource temporarily unavailable";
  else if (err == 42) return "No message of desired type";
  else if (err == 43) return "Identifier removed";
  else if (err == 44) return "Channel number out of range";
  else if (err == 45) return "Level 2 not synchronized";
  else if (err == 46) return "Level 3 halted";
  else if (err == 47) return "Level 3 reset";
  else if (err == 48) return "Link number out of range";
  else if (err == 49) return "Protocol driver not attached";
  else if (err == 50) return "No CSI structure available";
  else if (err == 51) return "Level 2 halted";
  else if (err == 52) return "Invalid exchange";
  else if (err == 53) return "Invalid request descriptor";
  else if (err == 54) return "Exchange full";
  else if (err == 55) return "No anode";
  else if (err == 56) return "Invalid request code";
  else if (err == 57) return "Invalid slot";
  else if (err == 35) return "Resource deadlock avoided";
  else if (err == 59) return "Bad font file format";
  else if (err == 60) return "Device not a stream";
  else if (err == 61) return "No data available";
  else if (err == 62) return "Timer expired";
  else if (err == 63) return "Out of streams resources";
  else if (err == 64) return "Machine is not on the network";
  else if (err == 65) return "Package not installed";
  else if (err == 66) return "Object is remote";
  else if (err == 67) return "Link has been severed";
  else if (err == 68) return "Advertise error";
  else if (err == 69) return "Srmount error";
  else if (err == 70) return "Communication error on send";
  else if (err == 71) return "Protocol error";
  else if (err == 72) return "Multihop attempted";
  else if (err == 73) return "RFS specific error";
  else if (err == 74) return "Bad message";
  else if (err == 75) return "Value too large for defined data type";
  else if (err == 76) return "Name not unique on network";
  else if (err == 77) return "File descriptor in bad state";
  else if (err == 78) return "Remote address changed";
  else if (err == 79) return "Can not access a needed shared library";
  else if (err == 80) return "Accessing a corrupted shared library";
  else if (err == 81) return ".lib section in a.out corrupted";
  else if (err == 82) return "Attempting to link in too many shared libraries";
  else if (err == 83) return "Cannot exec a shared library directly";
  else if (err == 84) return "Invalid or incomplete multibyte or wide character";
  else if (err == 85) return "Interrupted system call should be restarted";
  else if (err == 86) return "Streams pipe error";
  else if (err == 87) return "Too many users";
  else if (err == 88) return "Socket operation on non-socket";
  else if (err == 89) return "Destination address required";
  else if (err == 90) return "Message too long";
  else if (err == 91) return "Protocol wrong type for socket";
  else if (err == 92) return "Protocol not available";
  else if (err == 93) return "Protocol not supported";
  else if (err == 94) return "Socket type not supported";
  else if (err == 95) return "Operation not supported";
  else if (err == 96) return "Protocol family not supported";
  else if (err == 97) return "Address family not supported by protocol";
  else if (err == 98) return "Address already in use";
  else if (err == 99) return "Cannot assign requested address";
  else if (err == 100) return "Network is down";
  else if (err == 101) return "Network is unreachable";
  else if (err == 102) return "Network dropped connection on reset";
  else if (err == 103) return "Software caused connection abort";
  else if (err == 104) return "Connection reset by peer";
  else if (err == 105) return "No buffer space available";
  else if (err == 106) return "Transport endpoint is already connected";
  else if (err == 107) return "Transport endpoint is not connected";
  else if (err == 108) return "Cannot send after transport endpoint shutdown";
  else if (err == 109) return "Too many references: cannot splice";
  else if (err == 110) return "Connection timed out";
  else if (err == 111) return "Connection refused";
  else if (err == 112) return "Host is down";
  else if (err == 113) return "No route to host";
  else if (err == 114) return "Operation already in progress";
  else if (err == 115) return "Operation now in progress";
  else if (err == 116) return "Stale file handle";
  else if (err == 117) return "Structure needs cleaning";
  else if (err == 118) return "Not a XENIX named type file";
  else if (err == 119) return "No XENIX semaphores available";
  else if (err == 120) return "Is a named type file";
  else if (err == 121) return "Remote I/O error";
  else if (err == 122) return "Disk quota exceeded";
  else if (err == 123) return "No medium found";
  else if (err == 124) return "Wrong medium type";
  else if (err == 125) return "Operation canceled";
  else if (err == 126) return "Required key not available";
  else if (err == 127) return "Key has expired";
  else if (err == 128) return "Key has been revoked";
  else if (err == 129) return "Key was rejected by service";
  else if (err == 130) return "Owner died";
  else if (err == 131) return "State not recoverable";
  else if (err == 132) return "Operation not possible due to RF-kill";
  else if (err == 133) return "Memory page has hardware error";
}

